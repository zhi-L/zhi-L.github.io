<!DOCTYPE html>
<html lang="zh">

<head>
      <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />


  <title>Linux进程优先级的处理--Linux进程的管理与调度</title>


  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="referrer" content="origin" />
  <meta name="generator" content="Pelican" />
  <link href="/" rel="canonical" />

  <!-- Feed -->

  <link href="/theme/css/style.css" type="text/css" rel="stylesheet" />

  <!-- Code highlight color scheme -->
      <link href="/theme/css/code_blocks/darkly.css" rel="stylesheet">


  <!-- Custom fonts -->
  <link href='https://fonts.googleapis.com/css?family=Montserrat:400,300' rel='stylesheet' type='text/css' />
  <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css" />

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->


    <link href="/pages/2017/09/21/linuxjin-cheng-you-xian-ji-de-chu-li-linuxjin-cheng-de-guan-li-yu-diao-du/" rel="canonical" />

        <meta name="description" content="Linux进程优先级的处理--Linux进程的管理与调度">

        <meta name="author" content="luozhi">

        <meta name="tags" content="linux">




<!-- Open Graph -->
<meta property="og:site_name" content="智@DevOps之路"/>
<meta property="og:title" content="Linux进程优先级的处理--Linux进程的管理与调度"/>
<meta property="og:description" content="Linux进程优先级的处理--Linux进程的管理与调度"/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="/pages/2017/09/21/linuxjin-cheng-you-xian-ji-de-chu-li-linuxjin-cheng-de-guan-li-yu-diao-du/"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2017-09-21 17:00:00+08:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="/author/luozhi.html">
<meta property="article:section" content="linux"/>
<meta property="article:tag" content="linux"/>
<meta property="og:image" content="/theme/images/post-bg.jpg">

<!-- Twitter Card -->

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "name": "Linux进程优先级的处理--Linux进程的管理与调度",
  "headline": "Linux进程优先级的处理--Linux进程的管理与调度",
  "datePublished": "2017-09-21 17:00:00+08:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "luozhi",
    "url": "/author/luozhi.html"
  },
  "image": "/theme/images/post-bg.jpg",
  "url": "/pages/2017/09/21/linuxjin-cheng-you-xian-ji-de-chu-li-linuxjin-cheng-de-guan-li-yu-diao-du/",
  "description": "Linux进程优先级的处理--Linux进程的管理与调度"
}
</script>
</head>
<!-- TODO : Body class -->
<body class="home-template">

<nav id="menu">
  <a class="close-button">Close</a>
  <div class="nav-wrapper">
    <p class="nav-label">Menu</p>
    <ul>
          <li><a href="/pages/about/index.html" role="presentation">About</a></li>
          <li><a href="/categories.html" role="presentation">categories</a></li>
          <li><a href="/archives.html" role="presentation">archives</a></li>


    </ul>
  </div>
</nav>
    <!-- Progressbar -->
    <div class="progress-container">
        <span class="progress-bar"></span>
    </div>

    <!-- Page Header -->
    <!-- Set your background image for this header on the line below. -->
    <header id="post-header" class="has-cover">
      <div class="inner">
        <nav id="navigation">
            <span id="home-button" class="nav-button">
                <a class="home-button" href="/" title="Home"><i class="ic ic-arrow-left"></i> Home</a>
            </span>
          <span id="menu-button" class="nav-button">
            <a class="menu-button"><i class="ic ic-menu"></i> Menu</a>
          </span>
        </nav>
        <h1 class="post-title">Linux进程优先级的处理--Linux进程的管理与调度</h1>
        <!-- TODO : Proper class for headline -->
        <span class="post-meta">
                <a href="/author/luozhi.html">Luozhi</a>
            | <time datetime="四 21 九月 2017">四 21 九月 2017</time>
        </span>
        <!-- TODO : Modified check -->
            <div class="post-cover cover" style="background-image: url('/theme/images/post-bg.jpg')">
      </div>
    </header>

  <section id="wrapper">
    <a class="hidden-close"></a>

    <!-- Post content -->
    <main class="content" role="main">
        <article class="post">
        <div class="inner">
            <section class="post-content">
                <blockquote>
<p>http://blog.csdn.net/gatieme/article/details/51719208</p>
</blockquote>
<h2>1前景回顾</h2>
<h3>1.1 进程调度</h3>
<p>内存中保存了对每个进程的唯一描述, 并通过若干结构与其他进程连接起来.</p>
<p><strong>调度器</strong>面对的情形就是这样, 其任务是在程序之间共享CPU时间, 创造并行执行的错觉, 该任务分为两个不同的部分, 其中一个涉及<strong>调度策略</strong>, 另外一个涉及上<strong>下文切换</strong>.</p>
<p>内核必须提供一种方法, 在各个进程之间尽可能公平地共享CPU时间, 而同时又要考虑不同的任务优先级.</p>
<p>调度器的一个重要目标是有效地分配 CPU 时间片，同时提供很好的用户体验。调度器还需要面对一些互相冲突的目标，例如既要为关键实时任务最小化响应时间, 又要最大限度地提高 CPU 的总体利用率.</p>
<p>调度器的一般原理是, 按所需分配的计算能力, 向系统中每个进程提供最大的公正性, 或者从另外一个角度上说, 他试图确保没有进程被亏待.</p>
<h3>1.2 进程的分类</h3>
<p>linux把进程区分为实时进程和非实时进程, 其中非实时进程进一步划分为交互式进程和批处理进程</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>交互式进程(interactive process)</td>
<td>此类进程经常与用户进行交互, 因此需要花费很多时间等待键盘和鼠标操作. 当接受了用户的输入后, 进程必须很快被唤醒, 否则用户会感觉系统反应迟钝</td>
<td>shell, 文本编辑程序和图形应用程序</td>
</tr>
<tr>
<td>批处理进程(batch process)</td>
<td>此类进程不必与用户交互, 因此经常在后台运行. 因为这样的进程不必很快相应, 因此常受到调度程序的怠慢</td>
<td>程序语言的编译程序, 数据库搜索引擎以及科学计算</td>
</tr>
<tr>
<td>实时进程(real-time process)</td>
<td>这些进程由很强的调度需要, 这样的进程绝不会被低优先级的进程阻塞. 并且他们的响应时间要尽可能的短</td>
<td>视频音频应用程序, 机器人控制程序以及从物理传感器上收集数据的程序</td>
</tr>
</tbody>
</table>
<p>在linux中, 调度算法可以明确的确认所有实时进程的身份, 但是没办法区分交互式程序和批处理程序, linux2.6的调度程序实现了基于进程过去行为的启发式算法, 以确定进程应该被当做交互式进程还是批处理进程. 当然与批处理进程相比, 调度程序有偏爱交互式进程的倾向</p>
<h3>1.3 不同进程采用不同的调度策略</h3>
<p>根据进程的不同分类Linux采用不同的调度策略.</p>
<p>对于实时进程，采用FIFO, Round Robin或者Earliest Deadline First (EDF)最早截止期限优先调度算法|的调度策略.</p>
<p>对于普通进程，则需要区分交互式和批处理式的不同。传统Linux调度器提高交互式应用的优先级，使得它们能更快地被调度。而CFS和RSDL等新的调度器的核心思想是”完全公平”。这个设计理念不仅大大简化了调度器的代码复杂度，还对各种调度需求的提供了更完美的支持.</p>
<p>注意Linux通过将进程和线程调度视为一个，同时包含二者。进程可以看做是单个线程，但是进程可以包含共享一定资源（代码和/或数据）的多个线程。因此进程调度也包含了线程调度的功能.</p>
<p>目前非实时进程的调度策略比较简单, 因为实时进程值只要求尽可能快的被响应, 基于优先级, 每个进程根据它重要程度的不同被赋予不同的优先级，调度器在每次调度时, 总选择优先级最高的进程开始执行. 低优先级不可能抢占高优先级, 因此FIFO或者Round Robin的调度策略即可满足实时进程调度的需求.</p>
<p>但是普通进程的调度策略就比较麻烦了, 因为普通进程不能简单的只看优先级, 必须公平的占有CPU, 否则很容易出现进程饥饿, 这种情况下用户会感觉操作系统很卡, 响应总是很慢，因此在linux调度器的发展历程中经过了多次重大变动, linux总是希望寻找一个最接近于完美的调度策略来公平快速的调度进程.</p>
<h3>1.4 linux调度器的演变</h3>
<p>一开始的调度器是复杂度为<strong>的始调度算法</strong>(实际上每次会遍历所有任务，所以复杂度为O(n)), 这个算法的缺点是当内核中有很多任务时，调度器本身就会耗费不少时间，所以，从linux2.5开始引入赫赫有名的<strong>调度器</strong></p>
<p>然而，linux是集全球很多程序员的聪明才智而发展起来的超级内核，没有最好，只有更好，在调度器风光了没几天就又被另一个更优秀的调度器取代了，它就是<strong>CFS调度器Completely Fair Scheduler.</strong> 这个也是在2.6内核中引入的，具体为2.6.23，即从此版本开始，内核使用CFS作为它的默认调度器，调度器被抛弃了, 其实CFS的发展也是经历了很多阶段，最早期的楼梯算法(SD), 后来逐步对SD算法进行改进出RSDL(Rotating Staircase Deadline Scheduler), 这个算法已经是”完全公平”的雏形了， 直至CFS是最终被内核采纳的调度器, 它从RSDL/SD中吸取了完全公平的思想，不再跟踪进程的睡眠时间，也不再企图区分交互式进程。它将所有的进程都统一对待，这就是公平的含义。CFS的算法和实现都相当简单，众多的测试表明其性能也非常优越</p>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>版本</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>O(n)的始调度算法</td>
<td>linux-0.11~2.4</td>
</tr>
<tr>
<td>O(1)调度器</td>
<td>linux-2.5</td>
</tr>
<tr>
<td>CFS调度器</td>
<td>linux-2.6~至今</td>
</tr>
</tbody>
</table>
<h3>1.5 Linux的调度器组成</h3>
<p><strong>2个调度器</strong></p>
<p>可以用两种方法来激活调度</p>
<ul>
<li>
<p>一种是直接的, 比如进程打算睡眠或出于其他原因放弃CPU</p>
</li>
<li>
<p>另一种是通过周期性的机制, 以固定的频率运行, 不时的检测是否有必要</p>
</li>
</ul>
<p>因此当前linux的调度程序由两个调度器组成：<strong>主调度器</strong>，<strong>周期性调度器</strong>(两者又统称为<strong>通用调度器(generic scheduler)</strong>或<strong>核心调度器(core scheduler)</strong>)</p>
<p>并且每个调度器包括两个内容：<strong>调度框架</strong>(其实质就是两个函数框架)及<strong>调度器类</strong></p>
<p><strong>6种调度策略</strong></p>
<p>linux内核目前实现了6中调度策略(即调度算法), 用于对不同类型的进程进行调度, 或者支持某些特殊的功能</p>
<ul>
<li>
<p>SCHED_NORMAL和SCHED_BATCH调度普通的非实时进程</p>
</li>
<li>
<p>SCHED_FIFO和SCHED_RR和SCHED_DEADLINE则采用不同的调度策略调度实时进程</p>
</li>
<li>
<p>SCHED_IDLE则在系统空闲时调用idle进程.</p>
</li>
</ul>
<p><strong>5个调度器类</strong>
而依据其调度策略的不同实现了5个调度器类, 一个调度器类可以用一种种或者多种调度策略调度某一类进程, 也可以用于特殊情况或者调度特殊功能的进程.</p>
<p>其所属进程的优先级顺序为</p>
<div class="highlight"><pre><span></span>stop_sched_class -&gt; dl_sched_class -&gt; rt_sched_class -&gt; fair_sched_class -&gt; idle_sched_class
</pre></div>


<p><strong>3个调度实体</strong></p>
<p>调度器不限于调度进程, 还可以调度更大的实体, 比如实现组调度.</p>
<p>这种一般性要求调度器不直接操作进程, 而是处理可调度实体, 因此需要一个通用的数据结构描述这个调度实体,即seched_entity结构, 其实际上就代表了一个调度对象，可以为一个进程，也可以为一个进程组.</p>
<p>linux中针对当前可调度的实时和非实时进程, 定义了类型为seched_entity的3个调度实体</p>
<ul>
<li>
<p>sched_dl_entity 采用EDF算法调度的实时调度实体</p>
</li>
<li>
<p>sched_rt_entity 采用Roound-Robin或者FIFO算法调度的实时调度实体 rt_sched_class</p>
</li>
<li>
<p>sched_entity 采用CFS算法调度的普通非实时进程的调度实体</p>
</li>
</ul>
<p><strong>调度器整体框架</strong>
每个进程都属于某个调度器类(由字段task_struct-&gt;sched_class标识), 由调度器类采用进程对应的调度策略调度(由task_struct-&gt;policy )进行调度, task_struct也存储了其对应的调度实体标识</p>
<p>linux实现了6种调度策略, 依据其调度策略的不同实现了5个调度器类, 一个调度器类可以用一种或者多种调度策略调度某一类进程, 也可以用于特殊情况或者调度特殊功能的进程.</p>
<table>
<thead>
<tr>
<th>调度器类</th>
<th>调度策略</th>
<th>调度策略对应的调度算法</th>
<th>调度实体</th>
<th>调度实体对应的调度对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>stop_sched_class</td>
<td>无</td>
<td>无</td>
<td>无</td>
<td>特殊情况, 发生在cpu_stop_cpu_callback 进行cpu之间任务迁移migration或者HOTPLUG_CPU的情况下关闭任务</td>
</tr>
<tr>
<td>dl_sched_class</td>
<td>SCHED_DEADLINE</td>
<td>Earliest-Deadline-First最早截至时间有限算法</td>
<td>sched_dl_entity</td>
<td>采用DEF最早截至时间有限算法调度实时进程</td>
</tr>
<tr>
<td>rt_sched_class</td>
<td>SCHED_RR,SCHED_FIFO</td>
<td>Roound-Robin时间片轮转算法,FIFO先进先出算法</td>
<td>sched_rt_entity</td>
<td>采用Roound-Robin或者FIFO算法调度的实时调度实体</td>
</tr>
<tr>
<td>fair_sched_class</td>
<td>SCHED_NORMAL,SCHED_BATCH</td>
<td>CFS完全公平懂调度算法</td>
<td>sched_entity</td>
<td>采用CFS算法普通非实时进程</td>
</tr>
<tr>
<td>idle_sched_class</td>
<td>SCHED_IDLE</td>
<td>无</td>
<td>无</td>
<td>特殊进程, 用于cpu空闲时调度空闲进程idle</td>
</tr>
</tbody>
</table>
<h2>2 linux优先级的表示</h2>
<h3>2.1 优先级的内核表示</h3>
<p><strong>linux优先级概述</strong></p>
<blockquote>
<p>在用户空间通过nice命令设置进程的静态优先级, 这在内部会调用nice系统调用, 进程的nice值在-20~+19之间. 值越低优先级越高.</p>
<p>setpriority系统调用也可以用来设置进程的优先级. 它不仅能够修改单个线程的优先级, 还能修改进程组中所有进程的优先级, 或者通过制定UID来修改特定用户的所有进程的优先级</p>
</blockquote>
<p>内核使用一些简单的数值范围0~139表示内部优先级, 数值越低, 优先级越高。</p>
<p>从0-99的范围专供实时进程使用, nice的值[-20,19]则映射到范围100-139</p>
<blockquote>
<p>linux2.6内核将任务优先级进行了一个划分, 实时优先级范围是0到MAX_RT_PRIO-1（即99），而普通进程的静态优先级范围是从MAX_RT_PRIO到MAX_PRIO-1（即100到139）.</p>
</blockquote>
<table>
<thead>
<tr>
<th>优先级范围</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0——99</td>
<td>实时进程</td>
</tr>
<tr>
<td>100——139</td>
<td>非实时进程</td>
</tr>
</tbody>
</table>
<p><strong>内核的优先级表示</strong></p>
<p>内核表示优先级的所有信息基本都放在<code>include/linux/sched/prio.h</code>中, 其中定义了一些表示优先级的宏和函数.</p>
<p>优先级数值通过宏来定义, 如下所示,</p>
<p>其中MAX_NICE和MIN_NICE定义了nice的最大最小值</p>
<p>而MAX_RT_PRIO指定了实时进程的最大优先级, 而MAX_PRIO则是普通进程的最大优先级数值</p>
<div class="highlight"><pre><span></span>/*  http://lxr.free-electrons.com/source/include/linux/sched/prio.h?v<span class="o">=</span><span class="m">4</span>.6#L4 */
<span class="c1">#define MAX_NICE        19</span>
<span class="c1">#define MIN_NICE        -20</span>
<span class="c1">#define NICE_WIDTH      (MAX_NICE - MIN_NICE + 1)</span>

/* http://lxr.free-electrons.com/source/include/linux/sched/prio.h?v<span class="o">=</span><span class="m">4</span>.6#L24  */
<span class="c1">#define MAX_PRIO        (MAX_RT_PRIO + 40)</span>
<span class="c1">#define DEFAULT_PRIO        (MAX_RT_PRIO + 20)</span>
</pre></div>


<table>
<thead>
<tr>
<th>宏</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MIN_NICE</td>
<td>-20</td>
<td>对应于优先级100, 可以使用NICE_TO_PRIO和PRIO_TO_NICE转换</td>
</tr>
<tr>
<td>MAX_NICE</td>
<td>19</td>
<td>对应于优先级139, 可以使用NICE_TO_PRIO和PRIO_TO_NICE转换</td>
</tr>
<tr>
<td>NICE_WIDTH</td>
<td>40</td>
<td>nice值得范围宽度, 即[-20, 19]共40个数字的宽度</td>
</tr>
<tr>
<td>MAX_RT_PRIO, MAX_USER_RT_PRIO</td>
<td>100</td>
<td>实时进程的最大优先级</td>
</tr>
<tr>
<td>MAX_PRIO</td>
<td>140</td>
<td>普通进程的最大优先级</td>
</tr>
<tr>
<td>DEFAULT_PRIO</td>
<td>120</td>
<td>进程的默认优先级, 对应于nice=0</td>
</tr>
<tr>
<td>MAX_DL_PRIO</td>
<td>0</td>
<td>使用EDF最早截止时间优先调度算法的实时进程最大的优先级</td>
</tr>
</tbody>
</table>
<p>而内核提供了一组宏将优先级在各种不同的表示形之间转移</p>
<div class="highlight"><pre><span></span>//  http://lxr.free-electrons.com/source/include/linux/sched/prio.h?v=4.6#L27
/*
 * Convert user-nice values [ -20 ... 0 ... 19 ]
 * to static priority [ MAX_RT_PRIO..MAX_PRIO-1 ],
 * and back.
 */
#define NICE_TO_PRIO(nice)      ((nice) + DEFAULT_PRIO)
#define PRIO_TO_NICE(prio)      ((prio) - DEFAULT_PRIO)

/*
 * &#39;User priority&#39; is the nice value converted to something we
 * can work with better when scaling various scheduler parameters,
 * it&#39;s a [ 0 ... 39 ] range.
 */
#define USER_PRIO(p)            ((p)-MAX_RT_PRIO)
#define TASK_USER_PRIO(p)       USER_PRIO((p)-&gt;static_prio)
#define MAX_USER_PRIO           (USER_PRIO(MAX_PRIO))
</pre></div>


<p>还有一些nice值和rlimit值之间相互转换的函数nice_to_rlimit和rlimit_to_nice, 这在nice系统调用进行检查的时候很有用, 他们定义在include/linux/sched/prio.h, L47中, 如下所示</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Convert nice value [19,-20] to rlimit style value [1,40].</span>
<span class="cm"> */</span><span class="w"></span>
static<span class="w"> </span>inline<span class="w"> </span>long<span class="w"> </span>nice_to_rlimit<span class="o">(</span>long<span class="w"> </span>nice<span class="o">)</span><span class="w"></span>
<span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="o">(</span>MAX_NICE<span class="w"> </span><span class="o">-</span><span class="w"> </span>nice<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="err">;</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm"> * Convert rlimit style value [1,40] to nice value [-20, 19].</span>
<span class="cm"> */</span><span class="w"></span>
static<span class="w"> </span>inline<span class="w"> </span>long<span class="w"> </span>rlimit_to_nice<span class="o">(</span>long<span class="w"> </span>prio<span class="o">)</span><span class="w"></span>
<span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="o">(</span>MAX_NICE<span class="w"> </span><span class="o">-</span><span class="w"> </span>prio<span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="o">)</span><span class="err">;</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>
</pre></div>


<p><strong>DEF最早截至时间优先实时调度算法的优先级描述</strong>
此外新版本的内核还引入了EDF实时调度算法, 它的优先级比RT进程和NORMAL/BATCH进程的优先级都要高, 关于EDF的优先级的设置信息都早内核头文件include/linux/sched/deadline.h</p>
<p>因此内核将MAX_DL_PRIO设置为0, 可以参见内核文件include/linux/sched/deadline.h
<code>#define MAX_DL_PRIO             0</code>
此外也提供了一些EDF优先级处理所需的函数, 如下所示, 可以参见内核文件include/linux/sched/deadline.h</p>
<div class="highlight"><pre><span></span>static inline int dl_prio(int prio)
{
    if (unlikely(prio &lt; MAX_DL_PRIO))
            return 1;
    return 0;
}

static inline int dl_task(struct task_struct *p)
{
    return dl_prio(p-&gt;prio);
}

static inline bool dl_time_before(u64 a, u64 b)
{
    return (s64)(a - b) &lt; 0;
}
</pre></div>


<h3>2.2 进程的优先级表示</h3>
<div class="highlight"><pre><span></span>struct task_struct
{
    /* 进程优先级
     * prio: 动态优先级，范围为100~139，与静态优先级和补偿(bonus)有关
     * static_prio: 静态优先级，static_prio = 100 + nice + 20 (nice值为-20~19,所以static_prio值为100~139)
     * normal_prio: 没有受优先级继承影响的常规优先级，具体见normal_prio函数，跟属于什么类型的进程有关
     */
    int prio, static_prio, normal_prio;
    /* 实时进程优先级 */
    unsigned int rt_priority;
}
</pre></div>


<p><strong>动态优先级 静态优先级 实时优先级</strong></p>
<p>其中task_struct采用了三个成员表示进程的优先级:prio和normal_prio表示动态优先级, static_prio表示进程的静态优先级.</p>
<blockquote>
<p>为什么表示动态优先级需要两个值prio和normal_prio</p>
<p>调度器会考虑的优先级则保存在prio. 由于在某些情况下内核需要暂时提高进程的优先级, 因此需要用prio表示. 由于这些改变不是持久的, 因此静态优先级static_prio和普通优先级normal_prio不受影响.</p>
</blockquote>
<p>此外还用了一个字段rt_priority保存了实时进程的优先级</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>static_prio</td>
<td>用于保存静态优先级, 是进程启动时分配的优先级, ，可以通过nice和sched_setscheduler系统调用来进行修改, 否则在进程运行期间会一直保持恒定</td>
</tr>
<tr>
<td>rt_priority</td>
<td>用于保存实时优先级</td>
</tr>
<tr>
<td>normal_prio</td>
<td>表示基于进程的静态优先级static_prio和调度策略计算出的优先级. 因此即使普通进程和实时进程具有相同的静态优先级, 其普通优先级也是不同的, 进程分叉(fork)时, 子进程会继承父进程的普通优先级</td>
</tr>
<tr>
<td>prio</td>
<td>保存进程的动态优先级</td>
</tr>
</tbody>
</table>
<p>实时进程的优先级用实时优先级rt_priority来表示</p>
<h2>3 进程优先级的计算</h2>
<p>前面说了task_struct中的几个优先级的字段</p>
<table>
<thead>
<tr>
<th>静态优先级</th>
<th>实时优先级</th>
<th>普通优先级</th>
<th>动态优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td>static_prio</td>
<td>rt_priority</td>
<td>normal_prio</td>
<td>prio</td>
</tr>
</tbody>
</table>
<p>但是这些优先级是如何关联的呢, 动态优先级prio又是如何计算的呢?</p>
<h3>3.1 normal_prio函数设置普通优先级normal_prio</h3>
<p>静态优先级static_prio(普通进程)和实时优先级rt_priority(实时进程)是计算的起点 </p>
<p>因此他们也是进程创建的时候设定好的, 我们通过nice修改的就是普通进程的静态优先级static_prio</p>
<p>首先通过静态优先级static_prio计算出普通优先级normal_prio, 该工作可以由nromal_prio来完成, 该函数定义在kernel/sched/core.c#L861</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * __normal_prio - return the priority that is based on the static prio</span>
<span class="cm"> * 普通进程(非实时进程)的普通优先级normal_prio就是静态优先级static_prio</span>
<span class="cm"> */</span><span class="w"></span>
static<span class="w"> </span>inline<span class="w"> </span>int<span class="w"> </span>__normal_prio<span class="o">(</span>struct<span class="w"> </span>task_struct<span class="w"> </span><span class="o">*</span>p<span class="o">)</span><span class="w"></span>
<span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span>p<span class="o">-&gt;</span>static_prio<span class="err">;</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>

<span class="cm">/*</span>
<span class="cm"> * Calculate the expected normal priority: i.e. priority</span>
<span class="cm"> * without taking RT-inheritance into account. Might be</span>
<span class="cm"> * boosted by interactivity modifiers. Changes upon fork,</span>
<span class="cm"> * setprio syscalls, and whenever the interactivity</span>
<span class="cm"> * estimator recalculates.</span>
<span class="cm"> */</span><span class="w"></span>
static<span class="w"> </span>inline<span class="w"> </span>int<span class="w"> </span>normal_prio<span class="o">(</span>struct<span class="w"> </span>task_struct<span class="w"> </span><span class="o">*</span>p<span class="o">)</span><span class="w"></span>
<span class="err">{</span><span class="w"></span>
<span class="w">    </span>int<span class="w"> </span>prio<span class="err">;</span><span class="w"></span>

<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span>task_has_dl_policy<span class="o">(</span>p<span class="o">))</span><span class="w">              </span><span class="cm">/*  EDF调度的实时进程  */</span><span class="w"></span>
<span class="w">            </span>prio<span class="w"> </span><span class="o">=</span><span class="w"> </span>MAX_DL_PRIO<span class="o">-</span><span class="m">1</span><span class="err">;</span><span class="w"></span>
<span class="w">    </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span>task_has_rt_policy<span class="o">(</span>p<span class="o">))</span><span class="w">       </span><span class="cm">/*  普通实时进程的优先级  */</span><span class="w"></span>
<span class="w">            </span>prio<span class="w"> </span><span class="o">=</span><span class="w"> </span>MAX_RT_PRIO<span class="o">-</span><span class="m">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span>p<span class="o">-&gt;</span>rt_priority<span class="err">;</span><span class="w"></span>
<span class="w">    </span><span class="kr">else</span><span class="w">                                              </span><span class="cm">/*  普通进程的优先级  */</span><span class="w"></span>
<span class="w">            </span>prio<span class="w"> </span><span class="o">=</span><span class="w"> </span>__normal_prio<span class="o">(</span>p<span class="o">)</span><span class="err">;</span><span class="w"></span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span>prio<span class="err">;</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>
</pre></div>


<table>
<thead>
<tr>
<th>进程类型</th>
<th>调度器</th>
<th>普通优先级normal_prio</th>
</tr>
</thead>
<tbody>
<tr>
<td>EDF实时进程</td>
<td>EDF</td>
<td>MAX_DL_PRIO-1 = -1</td>
</tr>
<tr>
<td>普通实时进程</td>
<td>RT</td>
<td>MAX_RT_PRIO-1 - p-&gt;rt_priority = 99 - rt_priority</td>
</tr>
<tr>
<td>普通进程</td>
<td>CFS</td>
<td>__normal_prio(p) = static_prio</td>
</tr>
</tbody>
</table>
<p>普通优先级normal_prio需要根据普通进程和实时进程进行不同的计算, 其中__normal_prio适用于普通进程, 直接将普通优先级normal_prio设置为静态优先级static_prio. 而实时进程的普通优先级计算依据其实时优先级rt_priority.</p>
<h3>3.1.1 辅助函数task_has_dl_policy和task_has_rt_policy</h3>
<p>定义在kernel/sched/sched.h#L117 中</p>
<p>其本质其实就是传入task-&gt;policy调度策略字段看其值等于SCHED_NORMAL, SCHED_BATCH, SCHED_IDLE, SCHED_FIFO, SCHED_RR, SCHED_DEADLINE中的哪个, 从而确定其所属的调度类, 进一步就确定了其进程类型</p>
<div class="highlight"><pre><span></span>static inline int idle_policy(int policy)
{
    return policy == SCHED_IDLE;
}
static inline int fair_policy(int policy)
{
    return policy == SCHED_NORMAL || policy == SCHED_BATCH;
}

static inline int rt_policy(int policy)
{
    return policy == SCHED_FIFO || policy == SCHED_RR;
}

static inline int dl_policy(int policy)
{
        return policy == SCHED_DEADLINE;
}
static inline bool valid_policy(int policy)
{
        return idle_policy(policy) || fair_policy(policy) ||
                rt_policy(policy) || dl_policy(policy);
}

static inline int task_has_rt_policy(struct task_struct *p)
{
        return rt_policy(p-&gt;policy);
}

static inline int task_has_dl_policy(struct task_struct *p)
{
        return dl_policy(p-&gt;policy);
}
</pre></div>


<h3>3.1.2 关于rt_priority数值越大, 实时进程优先级越高的问题</h3>
<p>我们前面提到了数值越小, 优先级越高, 但是此处我们会发现rt_priority的值越大, 其普通优先级越小, 从而优先级越高.</p>
<p>因此网上出现了一种说法, 优先级越高？这又是怎么回事？难道有一种说法错了吗？</p>
<p>实际的原因是这样的，对于一个实时进程，他有两个参数来表明优先级——prio 和 rt_priority，</p>
<p>prio才是调度所用的最终优先级数值，这个值越小，优先级越高；</p>
<p>而rt_priority 被称作实时进程优先级，他要经过转化——prio=MAX_RT_PRIO - 1- p-&gt;rt_priority;</p>
<p>MAX_RT_PRIO = 100, ;这样意味着rt_priority值越大，优先级越高；</p>
<p>而内核提供的修改优先级的函数，是修改rt_priority的值，所以越大，优先级越高。</p>
<p>所以用户在使用实时进程或线程，在修改优先级时，就会有“优先级值越大，优先级越高的说法”，也是对的。</p>
<h3>3.1.3 为什么需要__normal_prio函数</h3>
<p>我们肯定会奇怪, 为什么增加了一个__normal_prio函数做了这么简单的工作, 这个其实是有历史原因的: 在早期的调度器中, 普通优先级的计算涉及相当多技巧性地工作, 必须检测交互式进程并提高其优先级, 而必须”惩罚”非交互进程, 以便是得系统获得更好的交互体验. 这需要很多启发式的计算, 他们可能完成的很好, 也可能不工作</p>
<h3>3.2 effective_prio函数设置动态优先级prio</h3>
<p>可以通过函数effective_prio用静态优先级static_prio计算动态优先级prio, 即· </p>
<div class="highlight"><pre><span></span>p-&gt;prio = effective_prio(p);
</pre></div>


<p>该函数定义在kernel/sched/core.c, line 861</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Calculate the current priority, i.e. the priority</span>
<span class="cm"> * taken into account by the scheduler. This value might</span>
<span class="cm"> * be boosted by RT tasks, or might be boosted by</span>
<span class="cm"> * interactivity modifiers. Will be RT if the task got</span>
<span class="cm"> * RT-boosted. If not then it returns p-&gt;normal_prio.</span>
<span class="cm"> */</span><span class="w"></span>
static<span class="w"> </span>int<span class="w"> </span>effective_prio<span class="o">(</span>struct<span class="w"> </span>task_struct<span class="w"> </span><span class="o">*</span>p<span class="o">)</span><span class="w"></span>
<span class="err">{</span><span class="w"></span>
<span class="w">    </span>p<span class="o">-&gt;</span>normal_prio<span class="w"> </span><span class="o">=</span><span class="w"> </span>normal_prio<span class="o">(</span>p<span class="o">)</span><span class="err">;</span><span class="w"></span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * If we are RT tasks or we were boosted to RT priority,</span>
<span class="cm">     * keep the priority unchanged. Otherwise, update priority</span>
<span class="cm">     * to the normal priority:</span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span><span class="err">!</span>rt_prio<span class="o">(</span>p<span class="o">-&gt;</span>prio<span class="o">))</span><span class="w"></span>
<span class="w">            </span><span class="kr">return</span><span class="w"> </span>p<span class="o">-&gt;</span>normal_prio<span class="err">;</span><span class="w"></span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span>p<span class="o">-&gt;</span>prio<span class="err">;</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>
</pre></div>


<p>我们会发现函数首先effective_prio设置了普通优先级, 显然我们用effective_prio同时设置了两个优先级(普通优先级normal_prio和动态优先级prio) 
因此计算动态优先级的流程如下</p>
<ul>
<li>
<p>设置进程的普通优先级(实时进程99-rt_priority, 普通进程为static_priority)</p>
</li>
<li>
<p>计算进程的动态优先级(实时进程则维持动态优先级的prio不变, 普通进程的动态优先级即为其普通优先级)</p>
</li>
</ul>
<p>最后, 我们综述一下在针对不同类型进程的计算结果</p>
<table>
<thead>
<tr>
<th>进程类型</th>
<th>实时优先级rt_priority</th>
<th>静态优先级static_prio</th>
<th>普通优先级normal_prio</th>
<th>动态优先级prio</th>
</tr>
</thead>
<tbody>
<tr>
<td>EDF调度的实时进程</td>
<td>rt_priority</td>
<td>不使用</td>
<td>MAX_DL_PRIO-1</td>
<td>维持原prio不变</td>
</tr>
<tr>
<td>RT算法调度的实时进程</td>
<td>rt_priority</td>
<td>不使用</td>
<td>MAX_RT_PRIO-1-rt_priority</td>
<td>维持原prio不变</td>
</tr>
<tr>
<td>普通进程</td>
<td>不使用</td>
<td>static_prio</td>
<td>static_prio</td>
<td>static_prio</td>
</tr>
<tr>
<td>优先级提高的普通进程</td>
<td>不使用</td>
<td>static_prio(改变)</td>
<td>static_prio</td>
<td>维持原prio不变</td>
</tr>
</tbody>
</table>
<h3>3.2.1 为什么effective_prio使用优先级数值检测实时进程</h3>
<p>t_prio会检测普通优先级是否在实时范围内, 即是否小于MAX_RT_PRIO.参见include/linux/sched/rt.h#L6</p>
<div class="highlight"><pre><span></span>static inline int rt_prio(int prio)
{
    if (unlikely(prio &lt; MAX_RT_PRIO))
        return 1;
    return 0;
}
</pre></div>


<p>而前面我们在normal_prio的时候, 则通过task_has_rt_policy来判断其policy属性来确定</p>
<div class="highlight"><pre><span></span>policy == SCHED_FIFO || policy == SCHED_RR;
</pre></div>


<p>那么为什么effective_prio重检测实时进程是rt_prio基于优先级数值, 而非task_has_rt_policy或者rt_policy?</p>
<p>对于临时提高至实时优先级的非实时进程来说, 这个是必要的, 这种情况可能发生在是哦那个实时互斥量(RT-Mutex)时.</p>
<h3>3.3 设置prio的时机</h3>
<ul>
<li>在新进程用wake_up_new_task唤醒时, 或者使用nice系统调用改变其静态优先级时, 则会通过effective_prio的方法设置p-&gt;prio<blockquote>
<p>wake_up_new_task(), 计算此进程的优先级和其他调度参数，将新的进程加入到进程调度队列并设此进程为可被调度的，以后这个进程可以被进程调度模块调度执行。</p>
</blockquote>
</li>
<li>进程创建时copy_process通过调用sched_fork来初始化和设置调度器的过程中会设置子进程的优先级</li>
</ul>
<h3>3.4 nice系统调用的实现</h3>
<p>nice系统调用是的内核实现是sys_nice, 其定义在kernel/sched/core.c#L7498，</p>
<p>它在通过一系列检测后, 通过set_user_nice函数， 其定义在kernel/sched/core.c#L3497</p>
<p>关于其具体实现我们会在另外一篇博客里面详细讲</p>
<h3>3.5 fork时优先级的继承</h3>
<p>在进程分叉处子进程时, 子进程的静态优先级继承自父进程. 子进程的动态优先级p-&gt;prio则被设置为父进程的普通优先级, 这确保了实时互斥量引起的优先级提高不会传递到子进程.</p>
<p>可以参照sched_fork函数, 在进程复制的过程中copy_process通过调用sched_fork来设置子进程优先级, 参见sched_fork函数</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * fork()/clone()-time setup:</span>
<span class="cm"> */</span><span class="w"></span>
int<span class="w"> </span>sched_fork<span class="o">(</span>unsigned<span class="w"> </span>long<span class="w"> </span>clone_flags<span class="o">,</span><span class="w"> </span>struct<span class="w"> </span>task_struct<span class="w"> </span><span class="o">*</span>p<span class="o">)</span><span class="w"></span>
<span class="err">{</span><span class="w"></span>
<span class="w">    </span><span class="cm">/*  ......  */</span><span class="w"></span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Make sure we do not leak PI boosting priority to the child.</span>
<span class="cm">     * 子进程的动态优先级被设置为父进程普通优先级 </span>
<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span>p<span class="o">-&gt;</span>prio<span class="w"> </span><span class="o">=</span><span class="w"> </span>current<span class="o">-&gt;</span>normal_prio<span class="err">;</span><span class="w"></span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Revert to default priority/policy on fork if requested.</span>
<span class="cm">     * sched_reset_on_fork标识用于判断是否恢复默认的优先级或调度策略</span>

<span class="cm">     */</span><span class="w"></span>
<span class="w">    </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span>unlikely<span class="o">(</span>p<span class="o">-&gt;</span>sched_reset_on_fork<span class="o">))</span><span class="w">  </span><span class="cm">/*  如果要恢复默认的调度策略, 即SCHED_NORMAL  */</span><span class="w"></span>
<span class="w">    </span><span class="err">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/*   首先是设置静态优先级static_prio</span>
<span class="cm">         *   由于要恢复默认的调度策略</span>
<span class="cm">         *   对于父进程是实时进程的情况, 静态优先级就设置为DEFAULT_PRIO</span>
<span class="cm">         *</span>
<span class="cm">         *   对于父进程是非实时进程的情况, 要保证子进程优先级不小于DEFAULT_PRIO</span>
<span class="cm">         *   父进程nice &lt; 0即static_prio &lt; 的重新设置为DEFAULT_PRIO的重新设置为DEFAULT_PRIO</span>
<span class="cm">         *   父进程nice &gt; 0的时候, 则什么也没做</span>
<span class="cm">         *   */</span><span class="w"></span>
<span class="w">        </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span>task_has_dl_policy<span class="o">(</span>p<span class="o">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span>task_has_rt_policy<span class="o">(</span>p<span class="o">))</span><span class="w"></span>
<span class="w">        </span><span class="err">{</span><span class="w"></span>
<span class="w">            </span>p<span class="o">-&gt;</span>policy<span class="w"> </span><span class="o">=</span><span class="w"> </span>SCHED_NORMAL<span class="err">;</span><span class="w">           </span><span class="cm">/*  普通进程调度策略  */</span><span class="w"></span>
<span class="w">            </span>p<span class="o">-&gt;</span>static_prio<span class="w"> </span><span class="o">=</span><span class="w"> </span>NICE_TO_PRIO<span class="o">(</span><span class="m">0</span><span class="o">)</span><span class="err">;</span><span class="w">   </span><span class="cm">/*  静态优先级为nice = 0 即DEFAULT_PRIO*/</span><span class="w"></span>
<span class="w">            </span>p<span class="o">-&gt;</span>rt_priority<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="err">;</span><span class="w">                             </span><span class="cm">/*  实时优先级为0  */</span><span class="w"></span>
<span class="w">        </span><span class="err">}</span><span class="w"></span>
<span class="w">        </span><span class="kr">else</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span>PRIO_TO_NICE<span class="o">(</span>p<span class="o">-&gt;</span>static_prio<span class="o">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0</span><span class="o">)</span><span class="w">  </span><span class="cm">/*  */</span><span class="w"></span>
<span class="w">            </span>p<span class="o">-&gt;</span>static_prio<span class="w"> </span><span class="o">=</span><span class="w"> </span>NICE_TO_PRIO<span class="o">(</span><span class="m">0</span><span class="o">)</span><span class="err">;</span><span class="w">   </span><span class="cm">/*  */</span><span class="w"></span>

<span class="w">        </span><span class="cm">/*  接着就通过__normal_prio设置其普通优先级和动态优先级</span>
<span class="cm">          *  这里做了一个优化, 因为用sched_reset_on_fork标识设置恢复默认调度策略后</span>
<span class="cm">          *  创建的子进程是是SCHED_NORMAL的非实时进程</span>
<span class="cm">          *  因此就不需要绕一大圈用effective_prio设置normal_prio和prio了 </span>
<span class="cm">          *  直接用__normal_prio设置就可  */</span><span class="w"></span>
<span class="w">        </span>p<span class="o">-&gt;</span>prio<span class="w"> </span><span class="o">=</span><span class="w"> </span>p<span class="o">-&gt;</span>normal_prio<span class="w"> </span><span class="o">=</span><span class="w"> </span>__normal_prio<span class="o">(</span>p<span class="o">)</span><span class="err">;</span><span class="w"> </span><span class="cm">/*  设置*/</span><span class="w"></span>

<span class="w">        </span><span class="cm">/*  设置负荷权重  */</span><span class="w"></span>
<span class="w">        </span>set_load_weight<span class="o">(</span>p<span class="o">)</span><span class="err">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * We don&#39;t need the reset flag anymore after the fork. It has</span>
<span class="cm">         * fulfilled its duty:</span>
<span class="cm">         */</span><span class="w"></span>
<span class="w">        </span>p<span class="o">-&gt;</span>sched_reset_on_fork<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="err">;</span><span class="w"></span>
<span class="w">    </span><span class="err">}</span><span class="w"></span>
<span class="w">    </span><span class="cm">/*  ......  */</span><span class="w"></span>
<span class="err">}</span><span class="w"></span>
</pre></div>


<h2>4 总结</h2>
<p>task_struct采用了四个成员表示进程的优先级:prio和normal_prio表示动态优先级, static_prio表示进程的静态优先级. 同时还用了rt_priority表示实时进程的优先级 </p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>static_prio</td>
<td>用于保存静态优先级, 是进程启动时分配的优先级, ，可以通过nice和sched_setscheduler系统调用来进行修改, 否则在进程运行期间会一直保持恒定</td>
</tr>
<tr>
<td>prio</td>
<td>进程的动态优先级, 这个有显示才是调度器重点考虑的进程优先级</td>
</tr>
<tr>
<td>normal_prio</td>
<td>普通进程的静态优先级static_prio和调度策略计算出的优先级. 因此即使普通进程和实时进程具有相同的静态优先级, 其普通优先级也是不同的, 进程分叉(fork)时, 子进程会继承父进程的普通优先级, 可以通过normal_prio来计算(非实时进程用static_prIo计算, 实时进程用rt_priority计算)</td>
</tr>
<tr>
<td>rt_priority</td>
<td>实时进程的静态优先级</td>
</tr>
</tbody>
</table>
<p>调度器会考虑的优先级则保存在prio. 由于在某些情况下内核需要暂时提高进程的优先级, 因此需要用prio表示. 由于这些改变不是持久的, 因此静态优先级static_prio和普通优先级normal_prio不受影响. 
此外还用了一个字段rt_priority保存了实时进程的优先级静态优先级static_prio(普通进程)和实时优先级rt_priority(实时进程)是计算的起点, 通过他们计算进程的普通优先级normal_prio和动态优先级prio.</p>
<p>内核通过normal_prIo函数计算普通优先级normal_prio 
通过effective_prio函数计算动态优先级prio </p>
            </section>

            <section class="post-info">
                <div class="post-share">
                    <a class="twitter" href="https://twitter.com/share?text=Linux进程优先级的处理--Linux进程的管理与调度&amp;url=/pages/2017/09/21/linuxjin-cheng-you-xian-ji-de-chu-li-linuxjin-cheng-de-guan-li-yu-diao-du/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="ic ic-twitter"></i><span class="hidden">Twitter</span>
                    </a>
                    <a class="facebook" href="https://www.facebook.com/sharer/sharer.php?u=/pages/2017/09/21/linuxjin-cheng-you-xian-ji-de-chu-li-linuxjin-cheng-de-guan-li-yu-diao-du/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="ic ic-facebook"></i><span class="hidden">Facebook</span>
                    </a>
                    <a class="googleplus" href="https://plus.google.com/share?url=/pages/2017/09/21/linuxjin-cheng-you-xian-ji-de-chu-li-linuxjin-cheng-de-guan-li-yu-diao-du/" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="ic ic-googleplus"></i><span class="hidden">Google+</span>
                    </a>
                    <div class="clear"></div>
                </div>

                <aside class="post-tags">
<a href="/tag/linux.html">linux</a>                </aside>

                <div class="clear"></div>

                <aside class="post-author">


                        <figure class="post-author-avatar">
                            <img src="/theme/images/avatar.png" alt="Luozhi" />
                        </figure>
                    <div class="post-author-bio">
                        <h4 class="post-author-name"><a href="/author/luozhi.html">Luozhi</a></h4>
                            <p class="post-author-about">罗智的博客，记录技术点滴。</p>
                            <span class="post-author-location"><i class="ic ic-location"></i> Shanghai</span>
                            <span class="post-author-website"><a href="http://blog.lzxmp.com"><i class="ic ic-link"></i> Website</a></span>
                    </div>
                    <div class="clear"></div>
                </aside>

                </section>

                <script type="text/javascript">
                    var disqus = 'luozhiblog';
                    var disqus_shortname = 'luozhiblog';
                    var disqus_identifier = '/pages/2017/09/21/linuxjin-cheng-you-xian-ji-de-chu-li-linuxjin-cheng-de-guan-li-yu-diao-du/';
                    var disqus_url = 'http://blog.lzxmp.com/pages/2017/09/21/linuxjin-cheng-you-xian-ji-de-chu-li-linuxjin-cheng-de-guan-li-yu-diao-du/';
                </script>
                <noscript>Please enable JavaScript to view the comments.</noscript>
                <section class="post-comments">
                        <a id="show-disqus" class="post-comments-activate" data-disqus-identifier="/pages/2017/09/21/linuxjin-cheng-you-xian-ji-de-chu-li-linuxjin-cheng-de-guan-li-yu-diao-du/" >Show Comments</a>
                    <div id="disqus_thread"></div>
                </section>

                <aside class="post-nav">
                    <a class="post-nav-next" href="/pages/2017/09/22/linuxjin-cheng-you-xian-ji-de-diao-zheng/">
                        <section class="post-nav-teaser">
                            <i class="ic ic-arrow-left"></i>
                                <h2 class="post-nav-title">linux进程优先级的调整</h2>
                            <p class="post-nav-excerpt">linux进程优先级的调整</p>
                        </section>
                    </a>
                    <a class="post-nav-prev" href="/pages/2017/09/12/pythonri-zhi-loggingmo-kuai-xiang-jie-yi/">
                        <section class="post-nav-teaser">
                            <i class="ic ic-arrow-right"></i>
                                <h2 class="post-nav-title">Python日志logging模块详解(一)</h2>
                            <p class="post-nav-excerpt">Python日志</p>
                        </section>
                    </a>
                    <div class="clear"></div>
                </aside>

            </div>
        </article>
    </main>
      <!-- TODO : Body class -->
    <div id="body-class" style="display: none;" class=""></div>

    <footer id="footer">
      <div class="inner">
        <section class="credits">


          <span class="credits-theme">Theme <a href="https://github.com/arulrajnet/attila" rel="nofollow">Attila</a></span>
          <span class="credits-software">Published with <a href="https://github.com/getpelican/pelican" rel="nofollow">Pelican</a></span>
        </section>
      </div>
    </footer>
  </section>

  <script type="text/javascript" src="/theme/js/script.js"></script>

    <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-105803699-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
    </script>
<script type="text/javascript">
    var disqus_shortname = 'luozhiblog';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>